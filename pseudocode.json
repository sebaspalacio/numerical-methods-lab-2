{
  "incremental": [
    "<strong>INPUT:</strong> function <em>f</em>, start <em>x_0</em>, step <em>&Delta;x</em>, max iterations <em>N</em>",
    "<strong>OUTPUT:</strong> interval [<em>x_i</em>, <em>x_{i+1}</em>] or failure",
    "1. Initialize <em>x_i</em> = <em>x_0</em>, <em>f_i</em> = <em>f</em>(<em>x_i</em>)",
    "2. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "3.     Set <em>x_{i+1}</em> = <em>x_i</em> + <em>&Delta;x</em>",
    "4.     Set <em>f_{i+1}</em> = <em>f</em>(<em>x_{i+1}</em>)",
    "5.     <strong>IF</strong> <em>f_i</em> * <em>f_{i+1}</em> < 0 <strong>THEN</strong>",
    "6.         <strong>RETURN</strong> Interval [<em>x_i</em>, <em>x_{i+1}</em>]",
    "7.     <strong>END IF</strong>",
    "8.     Set <em>x_i</em> = <em>x_{i+1}</em>, <em>f_i</em> = <em>f_{i+1}</em>",
    "9. <strong>END FOR</strong>",
    "10. <strong>RETURN</strong> Error: \"No sign change found\""
  ],
  "bisection": [
    "<strong>INPUT:</strong> continuous <em>f</em>, interval [<em>a</em>, <em>b</em>], tolerance <em>TOL</em>, max iter <em>N</em>",
    "<strong>OUTPUT:</strong> root <em>x_m</em>",
    "1. <strong>IF</strong> <em>f(a)f(b)</em> >= 0 <strong>THEN</strong> <strong>RETURN</strong> Error: \"Invalid Interval\"",
    "2. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "3.     Set <em>x_m</em> = (<em>a</em> + <em>b</em>) / 2",
    "4.     Calculate <em>f(x_m)</em>",
    "5.     <strong>IF</strong> <em>f(x_m)</em> == 0 <strong>OR</strong> error < <em>TOL</em> <strong>THEN</strong> <strong>RETURN</strong> <em>x_m</em>",
    "6.     <strong>IF</strong> <em>f(a)f(x_m)</em> < 0 <strong>THEN</strong>",
    "7.         Set <em>b</em> = <em>x_m</em>",
    "8.     <strong>ELSE</strong>",
    "9.         Set <em>a</em> = <em>x_m</em>",
    "10.    <strong>END IF</strong>",
    "11. <strong>END FOR</strong>",
    "12. <strong>RETURN</strong> Error: \"Max iterations reached\""
  ],
  "falsePosition": [
    "<strong>INPUT:</strong> continuous <em>f</em>, interval [<em>a</em>, <em>b</em>], <em>TOL</em>, <em>N</em>",
    "1. <strong>IF</strong> <em>f(a)f(b)</em> >= 0 <strong>THEN</strong> <strong>RETURN</strong> Error",
    "2. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "3.     Set <em>x_m</em> = <em>b</em> - (<em>f(b)</em>(<em>b</em>-<em>a</em>)) / (<em>f(b)</em>-<em>f(a)</em>)",
    "4.     <strong>IF</strong> <em>f(x_m)</em> == 0 <strong>OR</strong> error < <em>TOL</em> <strong>THEN</strong> <strong>RETURN</strong> <em>x_m</em>",
    "5.     <strong>IF</strong> <em>f(a)f(x_m)</em> < 0 <strong>THEN</strong> <em>b</em> = <em>x_m</em> <strong>ELSE</strong> <em>a</em> = <em>x_m</em>",
    "6. <strong>END FOR</strong>",
    "7. <strong>RETURN</strong> Error: \"Max iterations reached\""
  ],
  "fixedPoint": [
    "<strong>INPUT:</strong> function <em>g</em> (where <em>x=g(x)</em>), initial <em>x_0</em>, <em>TOL</em>, <em>N</em>",
    "1. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "2.     Set <em>x_{i+1}</em> = <em>g</em>(<em>x_i</em>)",
    "3.     Calculate error = |<em>x_{i+1}</em> - <em>x_i</em>|",
    "4.     <strong>IF</strong> error < <em>TOL</em> <strong>THEN</strong> <strong>RETURN</strong> <em>x_{i+1}</em>",
    "5.     Set <em>x_i</em> = <em>x_{i+1}</em>",
    "6. <strong>END FOR</strong>",
    "7. <strong>RETURN</strong> Error: \"Diverged or max iterations\""
  ],
  "newton_root": [
    "<strong>INPUT:</strong> <em>f</em>, <em>f'</em>, initial <em>x_0</em>, <em>TOL</em>, <em>N</em>",
    "1. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "2.     Calculate <em>y</em> = <em>f</em>(<em>x_i</em>) and <em>y'</em> = <em>f'</em>(<em>x_i</em>)",
    "3.     <strong>IF</strong> |<em>y'</em>| < epsilon <strong>THEN</strong> <strong>RETURN</strong> Error: \"Derivative zero\"",
    "4.     Set <em>x_{i+1}</em> = <em>x_i</em> - <em>y</em> / <em>y'</em>",
    "5.     <strong>IF</strong> |<em>x_{i+1}</em> - <em>x_i</em>| < <em>TOL</em> <strong>THEN</strong> <strong>RETURN</strong> <em>x_{i+1}</em>",
    "6.     Set <em>x_i</em> = <em>x_{i+1}</em>",
    "7. <strong>END FOR</strong>",
    "8. <strong>RETURN</strong> Error: \"Max iterations\""
  ],
  "secant": [
    "<strong>INPUT:</strong> <em>f</em>, initial <em>x_0</em>, <em>x_1</em>, <em>TOL</em>, <em>N</em>",
    "1. Set <em>f_0</em> = <em>f</em>(<em>x_0</em>), <em>f_1</em> = <em>f</em>(<em>x_1</em>)",
    "2. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "3.     Set <em>denom</em> = <em>f_1</em> - <em>f_0</em>",
    "4.     <strong>IF</strong> <em>denom</em> == 0 <strong>THEN</strong> <strong>RETURN</strong> Error: \"Division by zero\"",
    "5.     Set <em>x_{i+1}</em> = <em>x_1</em> - (<em>f_1</em> * (<em>x_1</em> - <em>x_0</em>)) / <em>denom</em>",
    "6.     <strong>IF</strong> |<em>x_{i+1}</em> - <em>x_1</em>| < <em>TOL</em> <strong>THEN</strong> <strong>RETURN</strong> <em>x_{i+1}</em>",
    "7.     Set <em>x_0</em> = <em>x_1</em>, <em>f_0</em> = <em>f_1</em>",
    "8.     Set <em>x_1</em> = <em>x_{i+1}</em>, <em>f_1</em> = <em>f</em>(<em>x_{i+1}</em>)",
    "9. <strong>END FOR</strong>",
    "10. <strong>RETURN</strong> Error"
  ],
  "multiple": [
    "<strong>INPUT:</strong> <em>f</em>, <em>f'</em>, <em>f''</em>, initial <em>x_0</em>, <em>TOL</em>, <em>N</em>",
    "1. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "2.     Evaluate <em>f</em>(<em>x_i</em>), <em>f'</em>(<em>x_i</em>), <em>f''</em>(<em>x_i</em>)",
    "3.     Set <em>denom</em> = (<em>f'</em>)^2 - <em>f</em> * <em>f''</em>",
    "4.     <strong>IF</strong> <em>denom</em> == 0 <strong>THEN</strong> <strong>RETURN</strong> Error",
    "5.     Set <em>x_{i+1}</em> = <em>x_i</em> - (<em>f</em> * <em>f'</em>) / <em>denom</em>",
    "6.     <strong>IF</strong> |<em>x_{i+1}</em> - <em>x_i</em>| < <em>TOL</em> <strong>THEN</strong> <strong>RETURN</strong> <em>x_{i+1}</em>",
    "7.     Set <em>x_i</em> = <em>x_{i+1}</em>",
    "8. <strong>END FOR</strong>",
    "9. <strong>RETURN</strong> Error"
  ],
  "gauss_simple": [
    "<strong>INPUT:</strong> Matrix <em>A</em> (nxn), Vector <em>b</em>",
    "1. Form Augmented Matrix <em>Ab</em> = [<em>A</em>|<em>b</em>]",
    "2. <strong>FOR</strong> k = 0 <strong>TO</strong> n-2 <strong>DO</strong> (Elimination):",
    "3.     <strong>FOR</strong> i = k+1 <strong>TO</strong> n-1 <strong>DO</strong>:",
    "4.         Set <em>m</em> = <em>Ab</em>[<em>i,k</em>] / <em>Ab</em>[<em>k,k</em>]",
    "5.         <strong>FOR</strong> j = k <strong>TO</strong> n <strong>DO</strong>:",
    "6.             <em>Ab</em>[<em>i,j</em>] = <em>Ab</em>[<em>i,j</em>] - <em>m</em> * <em>Ab</em>[<em>k,j</em>]",
    "7.         <strong>END FOR</strong>",
    "8.     <strong>END FOR</strong>",
    "9. <strong>END FOR</strong>",
    "10. Perform Backward Substitution to find <em>x</em>",
    "11. <strong>RETURN</strong> <em>x</em>"
  ],
  "gauss_partial": [
    "<strong>INPUT:</strong> Matrix <em>A</em>, Vector <em>b</em>",
    "1. Form <em>Ab</em> = [<em>A</em>|<em>b</em>]",
    "2. <strong>FOR</strong> k = 0 <strong>TO</strong> n-2 <strong>DO</strong>:",
    "3.     Find row <em>p</em> (where <em>p</em> >= <em>k</em>) with max absolute value in col <em>k</em>",
    "4.     <strong>IF</strong> <em>p</em> != <em>k</em> <strong>THEN</strong> Swap Row(k) with Row(p)",
    "5.     (Proceed with standard elimination step...)",
    "6. <strong>END FOR</strong>",
    "7. Perform Backward Substitution",
    "8. <strong>RETURN</strong> <em>x</em>"
  ],
  "gauss_total": [
    "<strong>INPUT:</strong> Matrix <em>A</em>, Vector <em>b</em>",
    "1. Form <em>Ab</em> = [<em>A</em>|<em>b</em>], Initialize Order Vector <em>marks</em> = [0...n-1]",
    "2. <strong>FOR</strong> k = 0 <strong>TO</strong> n-2 <strong>DO</strong>:",
    "3.     Find max value |<em>Ab</em>[<em>p,q</em>]| in submatrix <em>k</em> to <em>n</em>",
    "4.     Swap Row(k) with Row(p)",
    "5.     Swap Column(k) with Column(q) AND swap <em>marks</em>[<em>k</em>], <em>marks</em>[<em>q</em>]",
    "6.     (Proceed with standard elimination...)",
    "7. <strong>END FOR</strong>",
    "8. Solve for <em>x</em> using BackSub",
    "9. Reorder <em>x</em> using <em>marks</em> vector",
    "10. <strong>RETURN</strong> <em>x</em>"
  ],
  "lu_gaussian": [
    "<strong>INPUT:</strong> Matrix <em>A</em>",
    "1. Initialize <em>L</em> = Identity, <em>U</em> = 0",
    "2. <strong>FOR</strong> k = 0 <strong>TO</strong> n-1:",
    "3.     <em>U</em>[<em>k,k</em>] = <em>A</em>[<em>k,k</em>] - sum(<em>L</em>[<em>k,s</em>]<em>U</em>[<em>s,k</em>])",
    "4.     <strong>FOR</strong> i = k+1 <strong>TO</strong> n-1:",
    "5.         <em>L</em>[<em>i,k</em>] = (<em>A</em>[<em>i,k</em>] - sum(...)) / <em>U</em>[<em>k,k</em>]",
    "6.         <em>U</em>[<em>k,i</em>] = (<em>A</em>[<em>k,i</em>] - sum(...))",
    "7. <strong>RETURN</strong> <em>L</em>, <em>U</em> such that <em>A</em> = <em>L</em><em>U</em>"
  ],
  "lu_partial_pivot": [
    "<strong>INPUT:</strong> Matrix <em>A</em>",
    "1. Initialize <em>P</em> = Identity, <em>L</em> = Identity, <em>U</em> = <em>A</em>",
    "2. <strong>FOR</strong> k = 0 <strong>TO</strong> n-1:",
    "3.     Apply Partial Pivoting (swap rows in <em>U</em>, <em>L</em>, and <em>P</em>)",
    "4.     Compute multipliers and perform elimination on <em>U</em>",
    "5.     Store multipliers in <em>L</em>",
    "6. <strong>RETURN</strong> <em>P</em>, <em>L</em>, <em>U</em> such that <em>PA</em> = <em>L</em><em>U</em>"
  ],
  "cholesky": [
    "<strong>INPUT:</strong> Matrix <em>A</em> (Symmetric Positive Definite)",
    "1. Initialize <em>L</em> = Zeros(n,n)",
    "2. <strong>FOR</strong> i = 0 <strong>TO</strong> n-1:",
    "3.     <strong>FOR</strong> j = 0 <strong>TO</strong> i:",
    "4.         <em>sum</em> = sum(<em>L</em>[<em>i,k</em>] * <em>L</em>[<em>j,k</em>]) for k=0 to j-1",
    "5.         <strong>IF</strong> i == j:",
    "6.             <em>L</em>[<em>i,i</em>] = sqrt(<em>A</em>[<em>i,i</em>] - <em>sum</em>)",
    "7.         <strong>ELSE</strong>:",
    "8.             <em>L</em>[<em>i,j</em>] = (<em>A</em>[<em>i,j</em>] - <em>sum</em>) / <em>L</em>[<em>j,j</em>]",
    "9.     <strong>END FOR</strong>",
    "10. <strong>END FOR</strong>",
    "11. <strong>RETURN</strong> <em>L</em> such that <em>A</em> = <em>L</em><em>L^T</em>"
  ],
  "doolittle": [
    "<strong>INPUT:</strong> Matrix <em>A</em>",
    "<strong>METHOD:</strong> LU Factorization where <em>L</em> has 1s on diagonal",
    "1. <strong>FOR</strong> k = 0 <strong>TO</strong> n-1:",
    "2.     Compute row k of <em>U</em>",
    "3.     Compute col k of <em>L</em> (using <em>U[k,k]</em> as divisor)",
    "4. <strong>RETURN</strong> <em>L</em>, <em>U</em>"
  ],
  "crout": [
    "<strong>INPUT:</strong> Matrix <em>A</em>",
    "<strong>METHOD:</strong> LU Factorization where <em>U</em> has 1s on diagonal",
    "1. <strong>FOR</strong> k = 0 <strong>TO</strong> n-1:",
    "2.     Compute col k of <em>L</em>",
    "3.     Compute row k of <em>U</em> (using <em>L[k,k]</em> as divisor)",
    "4. <strong>RETURN</strong> <em>L</em>, <em>U</em>"
  ],
  "jacobi": [
    "<strong>INPUT:</strong> <em>A</em>, <em>b</em>, <em>x0</em>, <em>TOL</em>, <em>N</em>",
    "1. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "2.     <strong>FOR</strong> i = 0 <strong>TO</strong> n-1:",
    "3.         <em>sum</em> = 0",
    "4.         <strong>FOR</strong> j = 0 <strong>TO</strong> n-1 <strong>DO</strong>: <strong>IF</strong> j != i <strong>THEN</strong> <em>sum</em> += <em>A</em>[<em>i,j</em>]<em>x0</em>[<em>j</em>]",
    "5.         <em>x1</em>[<em>i</em>] = (<em>b</em>[<em>i</em>] - <em>sum</em>) / <em>A</em>[<em>i,i</em>]",
    "6.     <strong>END FOR</strong>",
    "7.     <strong>IF</strong> norm(<em>x1</em>-<em>x0</em>) < <em>TOL</em> <strong>RETURN</strong> <em>x1</em>",
    "8.     Set <em>x0</em> = <em>x1</em>",
    "9. <strong>END FOR</strong>",
    "10. <strong>RETURN</strong> Error: \"No convergence\""
  ],
  "gauss_seidel": [
    "<strong>INPUT:</strong> <em>A</em>, <em>b</em>, <em>x0</em>, <em>TOL</em>, <em>N</em>",
    "1. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "2.     <strong>FOR</strong> i = 0 <strong>TO</strong> n-1:",
    "3.         <em>sum</em> = 0",
    "4.         <strong>FOR</strong> j = 0 <strong>TO</strong> n-1 <strong>DO</strong>: <strong>IF</strong> j != i <strong>THEN</strong> <em>sum</em> += <em>A</em>[<em>i,j</em>]<em>x</em>[<em>j</em>]",
    "5.         <em>x</em>[<em>i</em>] = (<em>b</em>[<em>i</em>] - <em>sum</em>) / <em>A</em>[<em>i,i</em>]  (Update immediately)",
    "6.     <strong>END FOR</strong>",
    "7.     <strong>IF</strong> norm(error) < <em>TOL</em> <strong>RETURN</strong> <em>x</em>",
    "8. <strong>END FOR</strong>"
  ],
  "sor": [
    "<strong>INPUT:</strong> <em>A</em>, <em>b</em>, <em>x</em>, <em>w</em> (omega), <em>TOL</em>",
    "1. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "2.     <strong>FOR</strong> i = 0 <strong>TO</strong> n-1:",
    "3.         Compute Gauss-Seidel value <em>x_GS</em>",
    "4.         Set <em>x</em>[<em>i</em>] = (1 - <em>w</em>)<em>x</em>[<em>i</em>] + <em>w</em> * <em>x_GS</em>",
    "5.     <strong>END FOR</strong>",
    "6.     Check convergence",
    "7. <strong>END FOR</strong>"
  ],
  "vandermonde": [
    "<strong>INPUT:</strong> Points (<em>x_0</em>, <em>y_0</em>) ... (<em>x_n</em>, <em>y_n</em>)",
    "1. Construct matrix <em>V</em> where <em>V</em>[<em>i,j</em>] = <em>x_i</em>^(n-j)",
    "2. Construct vector <em>y</em>",
    "3. Solve linear system <em>V</em> * <em>a</em> = <em>y</em>",
    "4. <strong>RETURN</strong> coefficients <em>a</em>"
  ],
  "newton_interp": [
    "<strong>INPUT:</strong> Points (<em>x_i</em>, <em>y_i</em>)",
    "1. Initialize Table with <em>y_i</em> in first column",
    "2. <strong>FOR</strong> j = 1 <strong>TO</strong> n <strong>DO</strong>:",
    "3.     <strong>FOR</strong> i = 0 <strong>TO</strong> n-j <strong>DO</strong>:",
    "4.         <em>Table</em>[<em>i,j</em>] = (<em>Table</em>[<em>i+1,j-1</em>] - <em>Table</em>[<em>i,j-1</em>]) / (<em>x_{i+j}</em> - <em>x_i</em>)",
    "5.     <strong>END FOR</strong>",
    "6. <strong>END FOR</strong>",
    "7. <strong>RETURN</strong> Top row of Table (coefficients <em>b_k</em>)"
  ],
  "lagrange": [
    "<strong>INPUT:</strong> Points (<em>x_i</em>, <em>y_i</em>)",
    "1. Initialize <em>P(x)</em> = 0",
    "2. <strong>FOR</strong> k = 0 <strong>TO</strong> n <strong>DO</strong>:",
    "3.     Construct term <em>L_k(x)</em> = Product of (<em>x</em> - <em>x_j</em>)/(<em>x_k</em> - <em>x_j</em>) for all j != k",
    "4.     Add <em>y_k</em> * <em>L_k(x)</em> to <em>P(x)</em>",
    "5. <strong>END FOR</strong>",
    "6. <strong>RETURN</strong> Polynomial <em>P(x)</em>"
  ],
  "spline_linear": [
    "<strong>INPUT:</strong> Points (<em>x_0</em>, <em>y_0</em>) ... (<em>x_n</em>, <em>y_n</em>)",
    "1. <strong>FOR</strong> i = 0 <strong>TO</strong> n-1 <strong>DO</strong>:",
    "2.     Calculate slope <em>m_i</em> = (<em>y_{i+1}</em> - <em>y_i</em>) / (<em>x_{i+1}</em> - <em>x_i</em>)",
    "3.     Calculate intercept <em>b_i</em> = <em>y_i</em> - <em>m_i</em> * <em>x_i</em>",
    "4.     Define <em>S_i(x)</em> = <em>m_i</em> * <em>x</em> + <em>b_i</em> for <em>x</em> in [<em>x_i</em>, <em>x_{i+1}</em>]",
    "5. <strong>END FOR</strong>",
    "6. <strong>RETURN</strong> Set of functions {<em>S_0</em>, ..., <em>S_{n-1}</em>}"
  ],
  "spline_quadratic": [
    "<strong>INPUT:</strong> Points (<em>x_i</em>, <em>y_i</em>)",
    "<strong>GOAL:</strong> Find <em>a_i</em>, <em>b_i</em>, <em>c_i</em> for each interval",
    "1. Construct system of 3n equations:",
    "   - Interpolation: <em>S_i(x_i)</em> = <em>y_i</em>, <em>S_i(x_{i+1})</em> = <em>y_{i+1}</em>",
    "   - Continuity of <em>S'</em>: <em>S'_i(x_{i+1})</em> = <em>S'_{i+1}(x_{i+1})</em>",
    "   - Boundary condition: <em>S''_0(x_0)</em> = 0 (or <em>a_1</em> = 0)",
    "2. Solve linear system <em>Ax</em> = <em>b</em>",
    "3. <strong>RETURN</strong> Coefficients for each spline"
  ],
  "spline_cubic": [
    "<strong>INPUT:</strong> Points (<em>x_i</em>, <em>y_i</em>)",
    "<strong>GOAL:</strong> Find cubic polynomials <em>S_i(x)</em>",
    "1. Construct system for 4n unknowns (or n+1 moments):",
    "   - Interpolation conditions",
    "   - Continuity of <em>S</em>, <em>S'</em>, and <em>S''</em> at internal knots",
    "   - Natural Boundary: <em>S''_0(x_0)</em> = 0 and <em>S''_{n-1}(x_n)</em> = 0",
    "2. Solve system (often tridiagonal)",
    "3. <strong>RETURN</strong> Coefficients"
  ]
}
