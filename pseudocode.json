{
  "incremental": [
    "<strong>INPUT:</strong> function <em>f</em>, start <em>x0</em>, step <em>delta</em>, max_steps <em>N</em>",
    "<strong>OUTPUT:</strong> bracket [<em>a</em>, <em>b</em>] or failure",
    "1. Set <em>x_prev</em> = <em>x0</em>, <em>f_prev</em> = <em>f</em>(<em>x_prev</em>)",
    "2. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "3.     Set <em>x_curr</em> = <em>x_prev</em> + <em>delta</em>",
    "4.     Set <em>f_curr</em> = <em>f</em>(<em>x_curr</em>)",
    "5.     <strong>IF</strong> <em>f_prev</em> * <em>f_curr</em> < 0 <strong>THEN</strong> <strong>RETURN</strong> [<em>x_prev</em>, <em>x_curr</em>]",
    "6.     Set <em>x_prev</em> = <em>x_curr</em>, <em>f_prev</em> = <em>f_curr</em>",
    "7. <strong>END FOR</strong>",
    "8. <strong>RETURN</strong> Error: No root found"
  ],
  "bisection": [
    "<strong>INPUT:</strong> <em>f</em>, <em>a</em>, <em>b</em>, <em>TOL</em>, <em>N</em>",
    "1. <strong>IF</strong> <em>f(a)*f(b)</em> >= 0 <strong>RETURN</strong> Error",
    "2. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "3.     Set <em>m</em> = (<em>a</em>+<em>b</em>)/2",
    "4.     <strong>IF</strong> <em>f(m)</em> == 0 <strong>OR</strong> (<em>b</em>-<em>a</em>)/2 < <em>TOL</em> <strong>RETURN</strong> <em>m</em>",
    "5.     <strong>IF</strong> <em>f(a)*f(m)</em> < 0 <strong>THEN</strong> <em>b</em> = <em>m</em> <strong>ELSE</strong> <em>a</em> = <em>m</em>",
    "6. <strong>END FOR</strong>",
    "7. <strong>RETURN</strong> Error: Max iterations"
  ],
  "falsePosition": [
    "<strong>INPUT:</strong> <em>f</em>, <em>a</em>, <em>b</em>, <em>TOL</em>, <em>N</em>",
    "1. <strong>IF</strong> <em>f(a)*f(b)</em> >= 0 <strong>RETURN</strong> Error",
    "2. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "3.     Set <em>m</em> = <em>b</em> - <em>f(b)</em>*(<em>b</em>-<em>a</em>)/(<em>f(b)</em>-<em>f(a)</em>)",
    "4.     <strong>IF</strong> <em>f(m)</em> == 0 <strong>OR</strong> Error < <em>TOL</em> <strong>RETURN</strong> <em>m</em>",
    "5.     <strong>IF</strong> <em>f(a)*f(m)</em> < 0 <strong>THEN</strong> <em>b</em> = <em>m</em> <strong>ELSE</strong> <em>a</em> = <em>m</em>",
    "6. <strong>END FOR</strong>",
    "7. <strong>RETURN</strong> Error"
  ],
  "fixedPoint": [
    "<strong>INPUT:</strong> <em>g</em>, <em>x0</em>, <em>TOL</em>, <em>N</em>",
    "1. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "2.     Set <em>x1</em> = <em>g(x0)</em>",
    "3.     <strong>IF</strong> |<em>x1</em>-<em>x0</em>| < <em>TOL</em> <strong>RETURN</strong> <em>x1</em>",
    "4.     Set <em>x0</em> = <em>x1</em>",
    "5. <strong>END FOR</strong>",
    "6. <strong>RETURN</strong> Error"
  ],
  "newton_root": [
    "<strong>INPUT:</strong> <em>f</em>, <em>f'</em>, <em>x0</em>, <em>TOL</em>, <em>N</em>",
    "1. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "2.     <strong>IF</strong> |<em>f'(x0)</em>| < epsilon <strong>RETURN</strong> Error: Derivative zero",
    "3.     Set <em>x1</em> = <em>x0</em> - <em>f(x0)</em>/<em>f'(x0)</em>",
    "4.     <strong>IF</strong> |<em>x1</em>-<em>x0</em>| < <em>TOL</em> <strong>RETURN</strong> <em>x1</em>",
    "5.     Set <em>x0</em> = <em>x1</em>",
    "6. <strong>END FOR</strong>",
    "7. <strong>RETURN</strong> Error"
  ],
  "secant": [
    "<strong>INPUT:</strong> <em>f</em>, <em>x0</em>, <em>x1</em>, <em>TOL</em>, <em>N</em>",
    "1. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "2.     Set <em>denom</em> = <em>f(x1)</em> - <em>f(x0)</em>",
    "3.     <strong>IF</strong> <em>denom</em> == 0 <strong>RETURN</strong> Error",
    "4.     Set <em>x2</em> = <em>x1</em> - <em>f(x1)</em>*(<em>x1</em>-<em>x0</em>)/<em>denom</em>",
    "5.     <strong>IF</strong> |<em>x2</em>-<em>x1</em>| < <em>TOL</em> <strong>RETURN</strong> <em>x2</em>",
    "6.     Set <em>x0</em>=<em>x1</em>, <em>x1</em>=<em>x2</em>",
    "7. <strong>END FOR</strong>",
    "8. <strong>RETURN</strong> Error"
  ],
  "multiple": [
    "<strong>INPUT:</strong> <em>f</em>, <em>f'</em>, <em>f''</em>, <em>x0</em>, <em>TOL</em>, <em>N</em>",
    "1. <strong>FOR</strong> k = 1 <strong>TO</strong> N <strong>DO</strong>:",
    "2.     Set <em>denom</em> = (<em>f'(x0)</em>)^2 - <em>f(x0)f''(x0)</em>",
    "3.     <strong>IF</strong> <em>denom</em> == 0 <strong>RETURN</strong> Error",
    "4.     Set <em>x1</em> = <em>x0</em> - (<em>f(x0)f'(x0)</em>) / <em>denom</em>",
    "5.     <strong>IF</strong> |<em>x1</em>-<em>x0</em>| < <em>TOL</em> <strong>RETURN</strong> <em>x1</em>",
    "6.     Set <em>x0</em> = <em>x1</em>",
    "7. <strong>END FOR</strong>",
    "8. <strong>RETURN</strong> Error"
  ],
  "gauss_simple": [
    "<strong>INPUT:</strong> Matrix <em>A</em>, vector <em>b</em>",
    "1. Form augmented matrix <em>Ab</em> = [<em>A</em>|<em>b</em>]",
    "2. <strong>FOR</strong> k = 0 <strong>TO</strong> n-1 (Elimination):",
    "3.     <strong>IF</strong> <em>Ab[k,k]</em> == 0 <strong>RETURN</strong> Error: Zero pivot",
    "4.     <strong>FOR</strong> i = k+1 <strong>TO</strong> n:",
    "5.         <em>m</em> = <em>Ab[i,k]</em> / <em>Ab[k,k]</em>",
    "6.         Row(i) = Row(i) - <em>m</em> * Row(k)",
    "7. <strong>END FOR</strong>",
    "8. <em>x</em> = BackwardSubstitution(<em>Ab</em>)",
    "9. <strong>RETURN</strong> <em>x</em>"
  ],
  "gauss_partial": [
    "Same as Simple Gaussian, but at step k:",
    "1. Find row <em>p</em> (>= k) with max |<em>Ab[p,k]</em>|",
    "2. Swap Row(k) and Row(p)",
    "3. Proceed with elimination..."
  ],
  "gauss_total": [
    "Same as Simple Gaussian, but at step k:",
    "1. Find element (<em>p,q</em>) in submatrix with max value",
    "2. Swap Row(k) <-> Row(p)",
    "3. Swap Col(k) <-> Col(q) (Remember permutation!)",
    "4. Proceed with elimination...",
    "5. Un-permute solution <em>x</em> at the end"
  ],
  "lu_gaussian": [
    "<strong>INPUT:</strong> <em>A</em>",
    "<strong>OUTPUT:</strong> <em>L</em>, <em>U</em>",
    "1. <em>L</em> = Identity, <em>U</em> = Copy(<em>A</em>)",
    "2. <strong>FOR</strong> k = 0 <strong>TO</strong> n-1:",
    "3.     <strong>FOR</strong> i = k+1 <strong>TO</strong> n:",
    "4.         <em>m</em> = <em>U[i,k]</em> / <em>U[k,k]</em>",
    "5.         <em>L[i,k]</em> = <em>m</em>",
    "6.         Row(i) of U = Row(i) - <em>m</em> * Row(k)",
    "7. <strong>RETURN</strong> <em>L</em>, <em>U</em>"
  ],
  "lu_partial_pivot": [
    "<strong>INPUT:</strong> <em>A</em>",
    "<strong>OUTPUT:</strong> <em>P</em>, <em>L</em>, <em>U</em>",
    "1. Initialize <em>P</em> = Identity",
    "2. During elimination, if swapping Rows i and k:",
    "3.     Swap Rows i and k in <em>U</em>",
    "4.     Swap Rows i and k in <em>P</em>",
    "5.     Swap multipliers in <em>L</em> (carefully)",
    "6. <strong>RETURN</strong> <em>P</em>, <em>L</em>, <em>U</em>"
  ],
  "doolittle": [
    "<strong>Goal:</strong> <em>A</em> = <em>L</em><em>U</em> where <em>L[i,i]</em> = 1",
    "1. <strong>FOR</strong> k = 0 <strong>TO</strong> n-1:",
    "2.     Calc <em>U</em> row k: <em>u_kj</em> = <em>a_kj</em> - sum(<em>l_km</em>*<em>u_mj</em>)",
    "3.     Calc <em>L</em> col k: <em>l_ik</em> = (<em>a_ik</em> - sum(...)) / <em>u_kk</em>",
    "4. <strong>RETURN</strong> <em>L</em>, <em>U</em>"
  ],
  "crout": [
    "<strong>Goal:</strong> <em>A</em> = <em>L</em><em>U</em> where <em>U[i,i]</em> = 1",
    "1. Similar to Doolittle but invert roles of L and U diagonal",
    "2. Calc <em>L</em> col k first",
    "3. Calc <em>U</em> row k dividing by <em>l_kk</em>"
  ],
  "cholesky": [
    "<strong>INPUT:</strong> Symmetric, Positive-Definite <em>A</em>",
    "1. <strong>FOR</strong> i = 0 <strong>TO</strong> n-1:",
    "2.     <strong>FOR</strong> j = 0 <strong>TO</strong> i:",
    "3.         <em>sum</em> = sum(<em>L[i,k]*L[j,k]</em>)",
    "4.         <strong>IF</strong> i == j: <em>L[i,i]</em> = sqrt(<em>A[i,i]</em> - <em>sum</em>)",
    "5.         <strong>ELSE</strong>: <em>L[i,j]</em> = (<em>A[i,j]</em> - <em>sum</em>) / <em>L[j,j]</em>",
    "6. <strong>RETURN</strong> <em>L</em>"
  ],
  "jacobi": [
    "<strong>INPUT:</strong> <em>A</em>, <em>b</em>, <em>x0</em>, <em>TOL</em>",
    "1. <strong>FOR</strong> k = 1 <strong>TO</strong> N:",
    "2.     <strong>FOR</strong> i = 0 <strong>TO</strong> n:",
    "3.         <em>sum</em> = sum(<em>A[i,j]*x0[j]</em>) for j != i",
    "4.         <em>x1[i]</em> = (<em>b[i]</em> - <em>sum</em>) / <em>A[i,i]</em>",
    "5.     <strong>IF</strong> norm(<em>x1</em>-<em>x0</em>) < <em>TOL</em> <strong>RETURN</strong> <em>x1</em>",
    "6.     <em>x0</em> = <em>x1</em>",
    "7. <strong>RETURN</strong> Error"
  ],
  "gauss_seidel": [
    "<strong>INPUT:</strong> <em>A</em>, <em>b</em>, <em>x</em>, <em>TOL</em>",
    "1. Same as Jacobi, but use NEW values of <em>x[j]</em> as soon as available:",
    "2. <em>x[i]</em> = (<em>b[i]</em> - sum(known <em>x</em> terms)) / <em>A[i,i]</em>",
    "3. Check convergence after full pass"
  ],
  "sor": [
    "<strong>INPUT:</strong> <em>A</em>, <em>b</em>, <em>x</em>, <em>w</em>, <em>TOL</em>",
    "1. <strong>FOR</strong> i = 0 <strong>TO</strong> n:",
    "2.     <em>gs_val</em> = (<em>b[i]</em> - sum(...)) / <em>A[i,i]</em>",
    "3.     <em>x[i]</em> = (1-<em>w</em>)*<em>x[i]</em> + <em>w</em>*<em>gs_val</em>",
    "4. Check convergence"
  ],
  "vandermonde": [
    "<strong>INPUT:</strong> Points (x,y)",
    "1. Build Matrix <em>V</em> where <em>V[i,j]</em> = <em>x_i</em>^(n-1-j)",
    "2. Solve system <em>V</em> * <em>a</em> = <em>y</em>",
    "3. <strong>RETURN</strong> Coefficients <em>a</em>"
  ],
  "newton_interp": [
    "<strong>INPUT:</strong> Points (x,y)",
    "1. Initialize Divided Difference Table",
    "2. Col 0 = y values",
    "3. <strong>FOR</strong> j = 1 <strong>TO</strong> n:",
    "4.     <em>Table[i,j]</em> = (<em>Table[i+1,j-1]</em> - <em>Table[i,j-1]</em>) / (<em>x[i+j]</em> - <em>x[i]</em>)",
    "5. <strong>RETURN</strong> Diagonal elements (coefficients)"
  ],
  "lagrange": [
    "<strong>INPUT:</strong> Points (x,y)",
    "1. <strong>FOR</strong> k = 0 <strong>TO</strong> n:",
    "2.     Construct <em>L_k(x)</em> = product( (x-x_j)/(x_k-x_j) ) for j!=k",
    "3. Polynomial <em>P(x)</em> = sum( <em>y_k</em> * <em>L_k(x)</em> )"
  ],
  "spline_linear": [
    "<strong>INPUT:</strong> Points (x,y)",
    "1. <strong>FOR</strong> i = 0 <strong>TO</strong> n-1:",
    "2.     <em>m</em> = (<em>y[i+1]</em> - <em>y[i]</em>) / (<em>x[i+1]</em> - <em>x[i]</em>)",
    "3.     <em>eq</em>: <em>y</em> - <em>y[i]</em> = <em>m</em>*(<em>x</em> - <em>x[i]</em>)",
    "4. <strong>RETURN</strong> Equations"
  ],
  "spline_quadratic": [
    "<strong>INPUT:</strong> Points (x,y)",
    "1. Construct system for $3n$ unknowns ($a_i, b_i, c_i$)",
    "2. Equations: Interpolation (2n), Continuity (n-1), Smoothness (n-1)",
    "3. Boundary: $a_1 = 0$ (or $S''_1(x_0)=0$)",
    "4. Solve Linear System",
    "5. <strong>RETURN</strong> Coefficients"
  ],
  "spline_cubic": [
    "<strong>INPUT:</strong> Points (x,y)",
    "1. Construct system for $4n$ unknowns or solve for moments $M_i$",
    "2. Conditions: Interp, Continuity $S, S', S''$",
    "3. Natural Boundary: $S''(x_0) = 0, S''(x_n) = 0$",
    "4. Solve Tridiagonal System",
    "5. <strong>RETURN</strong> Coefficients"
  ]
}
